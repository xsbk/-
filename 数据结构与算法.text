 学习JavaScript数据结构与算法（第3版）
 一、JavaScript简介 
    JavaScript：函数式编程语言 前端开发 、后端开发（node）、移动端开发（Apache Cordova混合式开发框架）、用于嵌入式设备以及物联网（IoT）设备
    环境搭建
        浏览器控制台
        XAMPP
        node.js
    调试工具  debug
二、ECMAScript以及TypeScript
    babel.js:JavaScript转译器（源代码编译器），使用ECMAScript语言特性将JavaScript转换为es5特性的等价代码
    ES6新特性
        let、const和var
        模板字面量
        箭头函数
        默认参数
        数组展开以及表示剩余参数
        解构 变量互换
        属性简写
        类的声明
算法导论
    基础知识
    一、算法在生活中应用
        算法分析就是关于计算机性能与资源利用
    二、算法基础
        1、插入排序
            代码实现：
                for(var i=1;i<arr.length;i++){
                    var j=i-1;
                    var tmp = arr[i];
                    while(j>=0&&arr[j]>tmp){
                        arr[j+1] = arr[j];
                        j--;
                    }
                    arr[j+1] = tmp;
                }
            运行时间：
                影响因素：
                    输入规律
                    输入数组大小
            运行时间上界：
            最糟糕情况下：
                T(n)定义为输入规模为n时的最长运行时间
                T(n) = Θ(n^2)
            平均情况：T(n)定义为输入规模为n时的所有可能运行时间
        2、分析算法
            分析算法的结果意味着预测算法需要的资源
        3、设计算法
            分治法
                思想：将原问题分解成几个规模较小的但类似于原问题的子问题，递归地求解这些子问题，然后在合并这些子问题的解来建立原问题的解。
                步骤：
                    分解原问题为若干个子问题，这些子问题都是原问题的规模较小的实例
                    解决这些子问题，递归的求解出这些子问题
                    合并这些子问题的解
            分析分治算法
        循环不变式：
            三条性质：
                初始化：玄幻的第一次迭代之前，为真
                保持：如果循环某次迭代之前为真，之后也为真
                终止，在循环终止的时候，不变式为我们提供一个用性质，该性质有助于证明算法是正确的。
            可利用循环不变式证明算法的正确性
        伪代码中约定
            缩进表示块结构
            //注释
            NIL==null
    三、函数的增长
        是忽略掉那些依赖于计算机的常量，以及不去检查实际运行时间而是关注运行的增长。
        1、渐进记号
            抛弃低阶项并去除常量
            Θ：渐近紧确界
                等于 0<=c1g(n)<=f(n)<=c2g(n) ==>f(n) = Θ(g(n)) n>n0
                c1 = a/4,c2 = 7a/4
                是O与Ω的交集
            O渐进上界
                小于等于
                f(n) = O(g(n))
                    0<=f(n)<=c*g(n)
                    n0<=n,c>0
            Ω渐进下界
                大于等于
                f(n) = Ω(g(n))
                    0<=c*g(n)<=f(n)
                    n0<=n,c>0
            o 小于
            w 大于
            对于任意两个函数f(n)、g(n)，我们有f(n)=Θ(g(n)),当且仅当f(n)=O(g(n))且f(n)=Ω(g(n))
        2、标准记号与常用函数
            单调性
            取整
                𠃊x𠃎 向下取整
                ┍x┑ 向下取整 
            模运算
            多项式
            指数
                lim(1+x/n)^n = e^x;
                n->∞
            对数
            阶乘
                lg(n!) = Θ(nlgn)
            多重函数
            多重对数函数
            lg*n  增长特慢
            斐波那契数
                与黄金分割率以及其共轭数有关，是x^2=x+1的两个根
                    ∮= (1+5^1/2)
                    ∮'=(1-5^1/2)
                Fi = (∮ - ∮')/5^1/2
    四、分治策略
        1、最大子数组
            寻找数组A的和最大的连续子数组。
            暴力求解方法
                T(n) = n^2;
                var max = -Infinity;    //存储最大子数组和
                var maxI = 0;           //存储最大子数组和的开始下标
                var maxJ = 0;           //存储最大子数组和的结束下标
                for(var i =0;i<arr.length;i++){
                    var sum = 0;            //存储数组总和
                    for(var j = i;j<arr.length;j++){
                        sum += arr[j];
                        if(sum>max){
                            max = sum;
                            maxI =i;
                            maxJ = j;
                        }
                    }
                }
            分治法求解
                //线性时间内求出跨越中点的最大子数组
                function find_max_cross(arr,low,mid,high){
                    var left_sum=-Infinity,sum = 0,max_left;
                    for(var i = mid;i>=low;i--){
                        sum +=arr[i];
                        if(sum>left_sum){
                            left_sum = sum;
                            max_left = i;
                        }
                    }
                    var right_sum=-Infinity,sum = 0,max_right;
                    for(var j=mid+1;j<=high;j++){
                        sum +=arr[j];
                        if(sum>right_sum){
                            right_sum = sum;
                            max_right = j;
                        }
                    }
                    return {max_left,max_right,left_sum:(left_sum+right_sum)} 
                }
                //使用分治法分解
                var res ={};     //存储结果
                function find_max_subarray(arr,low,high){
                    if(low==high){
                        var sum = arr[low]
                        return {max_left:low,max_right:high,left_sum:sum};
                    }else{
                        var mid = Math.floor((low+high)/2);
                        var left_res = find_max_subarray(arr,low,mid)
                        var right_res = find_max_subarray(arr,mid+1,high)
                        var cross_res = find_max_cross(arr,low,mid,high)
                        var currres ={}; //存当前数组最大值
                        if(left_res.left_sum>=right_res.left_sum&&left_res.left_sum>=cross_res.left_sum){
                            currres = left_res
                        }else if(right_res.right_sum>=left_res.left_sum&&right_res.left_sum>=cross_res.left_sum){
                            currres = right_res
                        }else{
                            currres = cross_res
                        }
                    }
                    if(JSON.stringify(res)=="{}"||currres.left_sum>res.left_sum){ //JSON.stringify(res)=="{}"判断对象是否为空
                        res = currres;
                    }
                    return res;
                }
                时间复杂度 T(n) = Θ(nlgn)
        2、矩阵乘法Strassen算法
            矩阵乘法普通代码实现
                function fn(a,b){
                    n = a.length;
                    let c =[[]]
                    for(i = 0;i<n;i++){
                        for(var j=0;j<n;j++){
                            c[i][j] = 0;
                            for(var k =0;k<n;k++){
                                c[i][j]=a[i][k]+b[k][j]
                            }
                        }
                    }
                    return c;
                }
                T(n) = Θ(n^3)
            分治代码实现
                function fn(a,b){
                    n = a.rows
                    let c be a new n*n matrix
                    if(n==1){
                        c11=a11*b11
                    }else{
                        a,b,c 分解为最小的4个元素
                        c11 = fn(a11,b11)+fn(a12,b21)
                        c12 = fn(a11,b12)+fn(a12,b22)
                        c21 = fn(a21,b11)+fn(a22,b21)
                        c22 = fn(a21,b12)+fn(a22,b22)
                    }
                    return c
                }
                      -----Θ(1)     n=1;
                T(n)=|
                      -----8T(n/2)+ Θ(n^2)   n>1
                T(n) = Θ(n^3)
            Strassen方法实现
                核心思想：令递归树稍微不那么茂盛。
                步骤：
                    1、将矩阵分为n/2*n/2的矩阵
                    2、创建10个n/2*n/2的矩阵S1、S2....S10,每个矩阵保持步骤1中创建的两个子矩阵的和或者差
                    3、用步骤1和步骤2创建的10个矩阵，递归计算7个矩阵积P1、P2.。。P7.
                    4、通过pi矩阵的不同组合进行加减运算，计算出c11、c12、c21、c22 
                T(n) = n^lg7
        3、递归求解
            代入法
                1、假设
                2、归纳法
                T(n) = 4T(n/2)+n
                    假设为O(n^3)
                        T(n) = 4*c*(n/2)^3+n
                        T(N) = c*n^3/2+n
                        预想结果c*n^3
                        结果与实际之差，余项：c*n^3/2-n>=0 符合但至少是个大概值
                    假设为O(n)
                        T(n) = 4*c*(n/2)^2+n
                        T(n) = c*n^2+n
                        预想结果c*n^2
                        结果与实际之差，余项：-n<0 不符合
                    Θ(n)<T(n)<Θ(n^3)
                    假设为O(n^2)
                    假设T(n) = c1*k^2-c2*k;
                        T(n) = 4*(c1*(n/2)^2-c2*n/2)+n 
                            = c1*n^2-2c2*n+n 
                            =c1*n^2-(1-2c2)*n
                        预想 c1*n^2-c2*n 
                        余项 (c2-1)*n   c2>=1
            递归树法（不严谨）
                子叶数目、 一层一层累加
                将递归式转化为一颗树，其结点表示不同层次的递归调用产生的代价。然后采用边界和技术来求解递归式
            主方法 
                T(n) = aT(n/b)+f(n) a>=1,b>=1 f(n)渐近正函数
                若f(n) = O(n^logb(a))则T(n) = Θ(n^logb(a))  小于  
                若f(n) = Θ(n^logb(a))则T(n) = Θ(n^logb(a)*lng)  等于
                若f(n) = Ω(n^logb(a+Σ))则T(n) = Θ(f(n))    Σ>0为常数  大于
                证明主定理
    五、概率分析以及随机算法
        1、概率分析
            概率分析是在问题分析中应用概率的理念。
            平均情况运行时间
        2、指示器随机变量
            给定一个样本空间S和S中的一个事件A，设XA=I{A}，那么E[XA]=Pr{A} //E[XA]期望 Pr{A} 概率  I{A}是否发生
        
        3、随机算法
            一个算法的行为不仅由输入决定，而且还由随机数生成器产生的数量决定
            期望运行时间：随机算法运行时间
        4、概率分析与指示器随机变量
    排序和顺序统计量
    六、堆排序
        集合了归并和插入排序的优点
        二叉堆是数组，可以被看成一个近似的完全二叉树
            最大堆
                最大堆的性质是指出来根以外的所有结点i都要满足：A[PARENT(i)]>=A[i]，也就是说，某个结点的值至多与其父结点一样大。
            最小堆
        伪代码实现
            PARENT(i)
                return Math.floor([i/2])
            left(i)
                return Math.floor(2i)
            right(i)
                return Math.floor(2i+1)
            MAX-HEAPIFY(arr,i)
                l=left(i)
                r=right(i)
                if l<=arr.heap-size and arr[l]>arr[i]
                    larget = l
                else larget = i
                if r<=arr.heap-size and arr[r]>arr[larget]
                    larget = r;
                if larget!=i
                    exchange arr[i] arr[larget]
                    MAX-HEAPIFY(arr,larget)
        建堆
            bulid-max-heap(arr)
                arr.heap-size = arr.length;
                for i = Math.floor(arr.length/2) downto 1
                    MAX-HEAPIFY(arr,i)
            时间复杂度： Θ(n)
        堆排序算法
            heapsort(arr)
                bulid-max-heap(arr)
                for i=arr.length downto 2
                    exchange arr[l] with arr[i]
                    arr.heap-size = arr.heap-size-1
                    MAX-HEAPIFY(arr,i)
            整体代码实现
                function heap_max(arr,i){
                    var l = 2*i+1;
                    var r = 2*(i+1);
                    var larget = i;
                    if(l<arr.length&&arr[l]>arr[i]){
                        larget =l;
                    }
                    if(r<arr.length&&arr[r]>arr[larget]){
                        larget = r;
                    }
                    if(larget!=i){
                        var tmp = arr[i];
                        arr[i] = arr[larget];
                        arr[larget] = tmp;
                        heap_max(arr,larget);
                    }
                }
                function bulid_heap(arr){
                    for(var i=Math.floor(arr.length/2);i>=0;i--){
                        heap_max(arr,i)
                    }
                }
                function heap_sort(arr){
                    bulid_heap(arr)
                    var len = arr.length
                    var res = [];
                    for(var i=0;i<len;i++){
                        res.push(arr[0])
                        arr[0] = -Infinity;
                        heap_max(arr,0)
                        var index = arr.indexOf(-Infinity);
                        var e = arr.pop()
                        if(index!=arr.length){
                            arr[index] = e;
                        }
                    }
                    return res;
                }
            时间复杂度：Θ(nlgn)
        优先队列
            是一种用来维护由一组元素构成的集合S的数据结构，每个元素都有一个相关值（关键字）
            一个最大优先队列支持：
                INSERT(S，x)
                MAXIMUM(S) 返回最大关键字
                EXTRACT-MAX(S) 去掉并返回最大关键字
                INCREASE-KEY(S,x,k) 将元素x的关键字增加到k
            最小优先队列
                INSERT(S,x)
                MINIMUM()
                EXTRACT-MIN()
                DECREASE-KEY()
    七、快速排序
        特性：
            采用分治法、原地排序、节约内存。
            最坏情况和最好情况是交替出现的（随机化快速排序）。
            无需对输入序列做出任何假设，输入顺序不影响时间复杂度。
        步骤：
            分解：数组根据某一指定元素，将数组分为两个子数组，一个数组为小于指定元素，一个为大于等于指定元素。
            解决：通过递归调用快速排序，将两个子数组进行排序
            合并：因为子数组都是原地址排序，所以不需要合并（节约内存）
        代码实现
            伪代码：
            QUICKSORT(arr,p,r){
                if(p<r){
                    q = PARTITION(arr,p,r);
                    QUICKSORT(arr,p,q-1);
                    QUICKSORT(arr,q+1,r);
                }
            }
            PARTITION(arr,p,r)
                var x = arr[r];
                i = p-1;
                for j = pto r-1
                    if arr[j]<=x
                        i=i+1;
                        exchange arr[i] with arr[j]
               exchange arr[i+1] with arr[r]
                return i+1
            js代码实现 （递归实现）
            function QUICKSORT(arr,start,end){
                var ele = arr[start];
                var i = start;
                var j = end;
                if(i<j&&i>=0){  //注意条件
                    while(i!=j){
                        while(i<j&&arr[j]>ele){
                            j--;
                        }
                        while(i<j&&arr[i]<=ele){
                            i++;
                        }
                        if(i!=j){
                            var tmp = arr[i];
                            arr[i] = arr[j];
                            arr[j] = tmp;
                        }
                    }
                    arr[start] = arr[i];
                    arr[i] = ele;
                    QUICKSORT(arr,start,i-1);
                    QUICKSORT(arr,i+1,j);
                }
            }
        最坏情况下的时间复杂度：
            对已经排好序的排序
            T(n) = T(n-1)+Θ(n)  可使用递归树解出 再用归纳法验证
            T(n) = Θ(n^2) 类似插入排序
        最优情况
            T(n) = 2T(n/2) + Θ(n)
            T(n) = Θ(nlgn)
            当划分算法以9:1的比例划分时，
                T(n) = T(n/10) + T(9n/10) + Θ(n)
                时间复杂度为nlgn；（递归树求解）
        平均情况
            假设好坏交叉 T(n) = Θ(nlgn)
            L(n) = 2U(n/2) + Θ(n)
            U(n) = L(n-1)+Θ(n)
            L(n) = 2(L(n/2-1))+Θ(n/2)+Θ(n)
            L(n) = nlgn
        随机化快速排序
            期望运行时间：
                T(n) =  k=0->n [xk(T(k)+T(n-k-1)+Θ(n))]之和  //xk 表示k的概率
                E(T(n)) = k=0->n E(xk(T(k)+T(n-k-1)+Θ(n)))
                E(T(n)) = k=0->n E(xk)*E(T(k)+T(n-k-1)+Θ(n))
                E(T(n)) = k=0->n 2/n*E(T(k))+E(Θ(n))
                E(T(n)) = O(nlgn)
    八、线性时间排序
        排序算法下界
            决策树模型
                决策树是一棵完全二叉树，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作。
            最坏情况的下界
                在最坏情况下，任何比较排序算法都需要做Ω(nlgn)次比较
                    证明：
                        输入数据的结果种类：n!
                        可达到的叶结点：l
                        二叉树叶结点不超过：2^h
                        n!<=l<=2^h
                        h>=lg(n!)
                        h>=lg(n/e)^n 
                        h>= nlg(n/e)
                        h>= n(lgn-lge)  //lge=>Θ(1)
                        h = Ω(nlgn)
                堆排序和归并排序都是渐近最优的比较排序算法
        计数排序
            计数排序假设n个输入元素中的每个都是在0到k区间内的一个整数，其中k为某个整数。当k = O(n),排序的运行时间为 Θ(n)。
            基本思想：
                对每个输入元素x，确定小于x的元素个数，利用这一信息，就可以直接把x放到它输出数组的位置上了。
            代码实现
                counting-sort(A,B,k)
                    let C[0..k] be a new array
                    for i=0 to k 
                        C[i] = 0
                    for j=1 to A.length 
                        C[A[j]] ++;
                    for i =1 to k 
                        C[i] = C[i]+C[i-1]
                    for j =A.length downto 1
                        B[C[A[j]]] = A[j]
                        C[[A[j]]]--;
            js代码实现 
                function counting_sort(arr,res,k){
                    var savearr = [];
                    for(var i=0;i<=k;i++){
                        savearr[i] = 0;
                    }
                    for(var j=0;j<arr.length;j++){
                        savearr[arr[j]]++;
                    }
                    for(var i=1;i<=k;i++){
                        savearr[i] =savearr[i]+savearr[i-1]
                    }
                    for(var j =0;j<arr.length;j++){
                        res[savearr[arr[j]]] = arr[j];
                        savearr[arr[j]]--;
                    }
                    res.shift() //出去第一个空白
                    return res;
                }
                优化
                function counting_sort(arr){
                    var countArr = [];
                    var res = [];
                    var count =0;
                    for(var i=0;i<arr.length;i++){
                        countArr[arr[i]] = countArr[arr[i]]?countArr[arr[i]]+1:1;
                    }
                    for(var j=0;j<countArr.length;j++){
                        if(countArr[j]){
                            res[count] = j;
                            count++;
                            countArr[j]--;
                            j--;
                        }
                    }
                    return res;
                }
        基数排序
            是一种用在卡片排序机上的算法。
            给定n个d为数，其中每一个数位有k个可能的取值，如果RADIX-SORT使用的稳定排序方法耗时Θ(n+k，那么它就可以在Θ(d(n+k))时间内将这些数排好。
            给定一个b位数和任何正整数r<=b,如果RADIX-SORT使用的稳定排序算法对数据存储区间是0到k的输入进行排序耗时Θ(n+k),那么它就可以在Θ((b/r)(n+2^r))时间内将这些数排好。
            证明 
                以二进制划分 b为比特长 划分为b/r份 每份数值大小是0-2^r 
                T(n) = O(d(n+k))=>T(n) = O(b/r(n+2^r))
                r = lgn时 函数最小 T(n) = O(bn/lgn)
            代码实现
                var counter = [];
                function radixSort(arr, maxDigit) {
                    var mod = 10;
                    var dev = 1;
                    for (var i = 0; i < maxDigit; i++, dev *= 10, mod *= 10) {
                        for(var j = 0; j < arr.length; j++) {
                            var bucket = parseInt((arr[j] % mod) / dev);
                            if(counter[bucket]==null) {
                                counter[bucket] = [];
                            }
                            counter[bucket].push(arr[j]);
                        }
                        var pos = 0;
                        for(var j = 0; j < counter.length; j++) {
                            var value = null;
                            if(counter[j]!=null) {
                                while ((value = counter[j].shift()) != null) {
                                    arr[pos++] = value;
                                }
                            }
                        }
                    }
                    return arr;
                }
        桶排序
            假设输入数据服从均匀分布，平均情况下它的时间代价为O(n)
            BUCKET-SORT(arr)
                n = arr.length
                let res[0...n-1] be a new array
                for i=0 to n-1
                    make res[i] an empty list
                for i=1 to n
                    insert arr[i] into list res[narr[i]]
                for i=0 to n-1 
                    sort list res[i] with insertion sort
                concatenate the lists res[0],res[2]....res[n-1] together in order
    九、中位数和顺序统计量
        中位数
            数据顺序排序，位于中点的元素。 
            n为奇数时 i = (n+1)/2 
            偶数时 下中位数 i = n/2 上中位数 i = n/2+1
            不考虑奇偶性 下中位数 i = Math.floor(n+1/2) 上中位数 i = Math.floor(n+2/2)
        最大值
        最小值
        期望为线性时间的选择算法
            RANDOMIZED-PARTITION(arr,p,r)
                var x = arr[r];
                i = p-1;
                for j = p to r-1
                    if arr[j]<=x
                        i=i+1;
                        exchange arr[i] with arr[j]
                exchange arr[i+1] with arr[r]
                return i+1
            RANDOMIZED-SELECT(A,p,r,i)
                if p==r
                    return A[p]
                q = RANDOMIZED-PARTITION(A,p,r)
                k = q-p+1
                if i ==k 
                    return A[q]
                else if i<k 
                    return RANDOMIZED-SELECT(A,p,q-1,i)
                else return RANDOMIZED-SELECT(A,q+1,r,i+k)
            期望运行时间：
            E(T(n)) <=E[k=1->n X(k)*(T(max(k-1,n-k)))+O(n)]
                    <=k=1->n 1/n*E[(T(max(k-1,n-k)))+O(n)]
                    <=2/n*k=n/2->n-1 E[(T(k))+O(n)
                    <=cn -(cn/4-c/2-an)
            n>=(c/2)/(c/4-a)=2c/(c-4a)
            假设所有元素互异的，在期望线性时间内，我们可以找到任一顺序统计量，特别是中位数。
            function partition(arr,s,e){
                var x = arr[s];
                var i =s;
                for(var j = s+1;j<=e;j++){
                    if(arr[j]<=x){
                        i++;
                        var tmp =arr[j]
                        arr[j] = arr[i];
                        arr[i] =tmp;
                        
                    }
                }
                arr[s] = arr[i];
                arr[i] = x;
                return i;
            }
            function select(arr,s,e,i){
                if(s==e){
                    return arr[s];
                }else{
                    q = partition(arr,s,e);
                    console.log(arr,q,i)
                    if(i== q){
                        return arr[q];
                    }else if(i<q){
                        return select(arr,s,q,i)
                    }else{
                        return select(arr,q,e,i)
                    }
                }
            }
        最坏情况为线性时间的选择算法
    数据结构
    十、基本数据结构
        栈和队列
            栈和队列都是动态集合。
            栈 
                实现的是后进先出策略
                压入(push) 弹出(pop)
                栈下溢：试图对空栈执行弹出操作
                栈上溢：S.top超过了n 
                S.top指最新插入的元素 S[1]指栈底元素，S[S.top]是栈顶元素
                代码
                    STACK-EMPTY(S)
                    if S.top ==0
                        return true
                    else 
                        return false
                    
                    PUSH(S,x)
                        S.top = S.top+1
                        S[S.top] = x;
                    
                    POP(S)
                        if STACK-EMPTY(S)
                            error "underflow"
                        else S.top = S.top-1
                            return S[S.top+1]
            队列
                实现先进先出
                入队：enoueue 出队：dequeue
                队列有对头和队尾
                Q.head 指向队列头 Q.detail指向下一个将要插入的位置
                代码
                    ENQUEUE(Q,x)
                        Q[Q.tail] = x;
                        if Q.tail == Q.length
                            Q.tail =1
                        else Q.tail = Q.tail +1
                    DEQUEUE(Q)
                        x = Q[Q.head]
                        if Q.head = Q.length
                            Q.head =1
                        else Q.head = Q.head+1
                        return x;
            链表
                链表中的各个对象按线性顺序排列，是由各个对象里指针决定的。
                双向链表
                    L的每个元素都是个对象，每个对象有一个关键字key和两个指针，prev,next
                    L.head 指向链表第一个元素
                单链表
                    省略每个元素的prev指针
                循环链表
                    表头元素指向表尾元素
                链表的搜索
                    LIST-SEARCH(L,k)
                        x =L.head
                        while x!=NIL and x.key !=k
                            x = x.next 
                        return x 
                链表的插入
                    LIST-INSERT(L,x)
                        x.next = L.head 
                        if L.head !=NIL
                            L.head.prev = x 
                        L.head = x
                        x.prev =NIL
                链表的删除
                    LIST-DELETE(L,x)
                    if x.prev!=NIL
                        x.prev.next = x.next
                    else L.head = x.nxt 
                    if x.next !=NIL     
                        x.next.prev = x.prev
                哨兵
                    LIST-DELETE(L,x) //忽略表头和表尾
                        x.prev.next =x.next
                        x.next.prev = x.prev 
                    哨兵是一个哑对象，其作用是简化边界条件的处理。
                    LIST-SEARCH(L,k)
                        x = L.nil.next 
                        while x!=L.nil and x.key !=k 
                            x =x.next 
                        return x 
                    LIST-INSERT(L,x)
                        x.next = L.nil.next 
                        x.nil.next.prev = x
                        L.nil.next =x 
                        x.prev = L.nil
            指针和对象的实现
                对象的多数组表示
                    数组key、next、prev三个数组通过下标值将三个数组联系起来
                对象的单数组表示
                    将key、next、prev放于一个数组中，偏移量分别为0、1、2
                对象的分配与释放
                    自由表：存储自由对象，并且只有next指针，表头在free中（类似于一个栈）
                    ALLOCATE-OBJECT()
                        if free ==NIL 
                            error "out of space"
                        else x =free 
                            free = x.next 
                            return x;
                    PREE-OBJECT(x)
                        x.next = free 
                        free = x
            有根树的表示
            链式数据结构表示有根数
                二叉树 
                    p、left、right存放父结点、左孩子、右孩子 T.root指向整个树的根结点
                分支无限制的有根树
                树的其他表示方法
    十一、散列表（哈希表）
        散列表是实现字典操作的一种有效数据结构（普通数据概念的推广）。实际应用在，散列表查找的性能是极好的，查找一个元素的时间复杂度是O(1)
        直接寻址表
            DIRECT-ADDRESS-SEARCH(T,k)
                return T[k]
            DIRECT-ADDRESS-INSERT(T,x)
                T[x,key] = x
            DIRECT-ADDRESS-DELETE(T,x)
                T[x,key] = NIL
        散列表 
            散列表：是根据关键码值而直接进行访问的数据结构，也就是说通过把关键码值映射到表中一个位置来访问记录，以加快查找速度。
            这个映射函数教散列函数。存放记录的数组叫做散列表。
            冲突：多个关键字映射到同一个槽中
            装载因子a：每个槽平均数量 n个键 m个槽，装载因子为n/m
            简单均匀散列：假定任何一个给定的元素等可能的散列到m个槽中的任何一个，且与其他元素被散列到什么位置无关
            在简单均匀散列的假设下，对于链接法解决冲突的散列表，一次不成功查找的平均时间为O（1+a)
            在简单均匀散列的假设下，对于链接法解决冲突的散列表，一次成功查找的平均时间为O（1+a)
            常用方法：
                直接寻址法：取关键字或关键字的某个线性函数值为散列地址、
                数字分析法：
                    分析数据，找出规律，尽可能利用这些数据来构造冲突几率较低的散列地址
                平方取中法：
                    当无法确定关键字中哪几位分布均匀时，可以先求出关键字的平均值，然后按需要取平方值的中间几位作为哈希地址
                折叠法
                    将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和作为散列地址
                随机数法
                    选择随机函数，取关键字的随机值作为散列地址
                除法哈希法（除留余数法）
                        取关键字被某个不大于散列表表长m的数p除后所得余数为散列地址。
                        h(k) = k mod p (不能选择太小的p做除数)
                        最好取质数作为p的值，不要接近2的幂以及10的幂
            解决冲突问题：
                链接法：
                    把散列到同一槽中的所有元素都放在一个链表中。
                    最糟糕情况：散列表值全映射到一个槽中，相当于这个槽中数值长度等于散列表数值长度
                    CHAINED-HASH-INSERT(T,x)
                        insert x at the head of list T[h(x.key)]
                    CHAINED-HASH-SEARCH(T,k)
                        search for an element with key k in list T[h(k)]
                    CHAINED-HASH-DELETE(T,x)
                        delete x from the list T[h(x.key)]
                开发寻址法
                    没有链表，系统的探查哈希表。
                    Hi =(H(key)+di) mod m,i=1,2,3......,k(k<=m-1),其中H(key)为散列函数，m为散列列长，di为增量序列
                    di=1,2,3....m-1称为线性探测再散列
                    di=1^2,-1^2,2^2,-2^2....(+-)k^2(k<=m/2)称为二次探测再散列
                    di = 伪随机数序列，称为随机探测再散列
                    线性探查
                        给定一个普通的散列函数h':U->{0,1,2,...,M-1}，称之为辅助散列函数，线性探查采用的散列函数为h(k,i)=(h'(k)+i)mod m ,i=0,1,...,m-1
                    二次探查
                        h(k,i)=(h'(k)+c1*i+c2*i^2)mod m ,i=0,1,...,m-1
                    双重散列
                        是用于开放寻址的最好方法之一，因为他所产生的排列具有随机选择排列的许多特征
                建立一个公共溢出区
                再散列法
        散列函数
            好的散列函数特点：近似满足简单均匀散列假设
            将关键字转化为自然数
            除法散列法
            乘法散列法
                用关键字乘上A(0<A<1),并提取kA的小数部分，再用m乘以这个值向下取整
                h(k) = |_m(A*k mod 1)_|
                A = (5^1/2 -1)/2 =0.6180339887...(比较理想值)
            全域散列法
                随机的选择散列函数，使之独立于要存储的关键字
                设计一个全域散列函数
                    只需要一点数论方面的知识即可加以证明
        全域散列和完全散列
            全域散列：（随机性）随机选择散列函数
                如果h选自一组全域散列函数，将n个关键字散列到一个大小为m的表T中，并用链接法解决冲突。
                如果关键字k不在表中，则k被散列至其中的链表的期望长度E[n h(k)]至多为a =n/m,如果关
                键字k在表中，则包含关键字k  的链表的期望长度为E[n h(k)]至多1+a。
            完全散列
    十二、二叉搜索树
        二叉搜索树定义
            二叉搜索树是以二叉树来组织的，中间关键字满足，x的左子树中结点的key<=x.key,x的右子树中结点的key>=x.key;
            中序遍历：二叉搜索树允许通过一个简单的递归算法来按序输出二叉搜索树中的所有关键字。
                INORDER-TREE-WALK(x)
                    if x!= NIL
                        INORDER-TREE-WALK(x.left)
                        print(x)
                        INORDER-TREE-WALK(x.right)
            先序遍历：输出根的关键字在左右子树之前。
            后序遍历：输出根的关键字在其左右子树之后。
        查询二叉搜索树
            TREE-SEARCH(x,k)
                if x==NIL or k == x.ley 
                    return x 
                if k<x.key 
                    return TREE-SEARCH(x.left,k)
                else
                    return TREE-SEARCH(x.right,k)
            非递归
                ITERATIVE-TREE-SEARCH(x,k)
                    while x!=NIL and k!=x.key
                        if k<x.key
                            x =x.left
                        else 
                            x = x.right 
                    return x
            最大关键字元素以及最小关键字元素
                TREE-MINIMUM(x)
                    while x.left !=NIL
                        x =x.left
                    return x 
                TREE-MAXIMUM(x)
                    while x.right !=NIL
                        x =x.right
                    return x 
            后继和前驱
                TREE-SUCCESSOR(x)
                    if x.right!=NIL
                        return TREE-MINIMUM(x.right)
                    y =x.p 
                    while y!=NIL and x == y.right
                        x =y
                        y =y.p
                    return y
            插入和删除
                插入：
                TREE-INSERT(T,z)
                    y =NIL 
                    x = T.root 
                    while x!=NIL 
                        y =x 
                        if z.key<x.key 
                            x = x.left 
                        else x = x.right 
                    z.p = y
                    if y == NIL 
                        T.root = z 
                    elseif z.key < y.key 
                        y.left = z
                    else y.right = z
                删除：（第三种情况稍微复杂）
                    如果z没有孩子结点，那就只是将它简单的删除，并修改它的父节点，用NIL作为他对应的子节点
                    如果只有一个孩子，那就将孩子提升到z位置，并修改父节点对应的结点，变为z的孩子结点
                    如果有两个孩子，那么找z的后继y，并让y占据z位置，z的左子树成为y的新左子树，y的子树，将往y原来位置提升。
                        TRANSPLANT(T,u,v)
                            if u.p == NIL 
                                T.root =v 
                            elseif u == u.p.left 
                                u.p.left = v
                            else u.p.right = v 
                            if v!=-NIL 
                                v.p =u.p
                    TREE-DELETE(T,x)
                        if z.left == NIL
                            TRANSPLANT(T,z,z.right)
                        elseif z.right == NIL 
                            TRANSPLANT(T,z,z.left)
                        elsse y= TRee-MINIMUM(z.right)
                            if y.p!= z
                                TRANSPLANT(T,y,y.right)
                                y.right =z.right 
                                y.right.p = y
                            TRANSPLANT(T,z,y)
                            y.left = z.left
                            y.left.p = p
        随机构建二叉搜索树
            一颗有n个不同的关键字的随机构建二叉搜索树的期望高度为O(lgn)
    十三、红黑树
        红黑树是一颗二叉树，它在每个结点上增加了一个存储位来表示结点的颜色。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长2倍，因而近似平衡。
        结点属性：color key left right p
        特点：
            每个结点或是红色。或是黑色的
            根结点是黑色
            每个叶结点是黑色的
            如果一个结点是红色的，则它的两个子节点都是黑色的
            对每个结点，从该结点到其所有后代叶结点的简单路径上，均包含相同数目的黑色结点。
        黑高：从某个结点x出发（不含x）到达一个叶结点的任意一条简单路径上的黑色结点个数称为该结点的黑高。 
        一颗有n个内部结点的红黑树的高度至多为2lg(n+1)
        旋转：
            左旋：
                 y                      x
                / \        右旋        / \
               x   r      ----->      a   y
              / \         <----          / \
             a   b         左旋          b   r 
            左旋：
                LEFT-ROTATE(T,x)
                    y = x.right 
                    x.right = y.left
                    if y.left!= T.nil 
                        y.left.p = x
                    y.p = x.p 
                    if x.p == T.nil 
                        T.root = y
                    elseif x == x.p.left 
                        x.p.left = y
                    else x.p.right = y
                        y.left = x
                        x.p = y
        插入：
            RB-INSERT(T,z)
                y = T.nil 
                x = T.root 
                while x!=T.nil 
                    y = x
                    if z.key <x.key
                        x= x.left
                    else x = x.right
                z.p =y
                if y =T.nil 
                    T.root = z
                elseif z.key <y.key
                    y.left = z
                else y.right = z
                z-left = T.nil 
                z.right = T.nil 
                z.color = RED 
                RB-INSERT-FIXUP(T,x)
            RB-INSERT-FIXUP(T,x)
                while z.p.color = RED
                    if z.p ==z.p.p.left 
                        y =z.p.p.right
                        if y.color == RED 
                            z.p.color = BLACK
                            y.color = BLACK
                            z.p.p.color = RED 
                            z = z.p.p
                        else if z==z.p.right
                            z=z.p
                            LEFT-ROTATE(T,z)
                        z.p.color = BLACK 
                        z.p.p.color = RED 
                        RIGHT-ROTATE(T,z.p.p)
                    else same as then clause with "right" and "left" exchanged
                T.root.color = BLACK
            三种情况：（注意在插入一个红子树之后要满足红黑树的特点）
                z的叔结点y是红色 （z.p.p与z.p.p.left以及z.p.p.right交换颜色 递归实现）
                z的叔结点y是黑色，且z是一个右孩子（旋转实现）
                z的叔结点y是黑色，且z是一个左孩子（旋转实现）
        删除：
            RB-TRANSPLANT(T,u,v)
                if u.p == T.nil 
                    T.root = v
                elseif u == u.p.left
                    u.p.left = v 
                else u.p.right = v 
                v.p = u.p
            RB-DELETE(T,z)
                y = z
                y-original-color = y.color
                if z.left == T.nil
                    x = z.right
                    RB-TRANSPLANT(T,z,z.right)
                elseif z.right == T.nil 
                    x =z.left 
                    RB-TRANSPLANT(T,z,z.left)
                else y = TREE-MINIMUM(z.right)
                    y-original-color = y.color
                    x = y.right 
                    if y.p == z 
                        x.p = y
                    else RB-TRANSPLANT(T,y,y.right)
                        y.right = z.right 
                        y.right.p = y
                    RB-TRANSPLANT(T,z,y)
                    y.left = z.left 
                    y.left.p = y
                    y.color = z.color
                    if y-original -color == BLACK
                        RB-DELETE-FIXUP(T,x)
            四种情况：
                x的兄弟结点w是红色的
                x的兄弟结点w是黑色的，而且w的两个子结点都是黑色的
                x的兄弟结点是黑色的，而且w的左孩子红色，右孩子黑色
                x的兄弟结点w是黑色的，且右孩子是红色的
    十四、数据结构和扩张
        动态顺序统计
            秩：元素在集合线性序中的位置
            顺序统计树T：只是简单地在每个结点上存储附加信息的一棵红黑树。（key、left、right、color、size、p）
                x.size = x.left.size+x.right.size+1
            查找给定秩的元素
                OS-SELECT(x,i)
                    r = x.left.size+1
                    if i == r 
                        return x 
                    elseif i < r
                        return OS-SELECT(x.left,i)
                    else return OS-SELECT(x.right,i-r)
            确定一个元素的秩
                OS-RANK(T,x)
                    r = x.left.size+1
                    y = x 
                    while y!=T.root 
                        if y == y.p.right 
                            r = r+y.p.left.size+1
                        y =y.p
                    return r
            对子树规模的维护
        如何扩张数据结构
            步骤：
                选择一种基础数据结构
                确定基础数据结构中要维护的附加信息
                检验基础数据结构上的基本修改操作能否维护附加信息
                设计一些新的操作
            对于红黑树的扩张
                设f是n个结点的红黑树T扩张的属性，且假设对任意结点x，f的值仅依赖与结点x.left和x.right的信息。还可能包括x.left.f和x.right.f。那么我们可以在插入和删除操作期间对T的所有结点的f值进行维护，并且不影响这两个操作的O(lgn)渐近时间性能。
        区间树
            闭区间
            开区间
            半开区间
            区间：便于表示占用一连续时间段的一些事情
            低端点
            高端点
            区间三分律：
                i与i'重叠
                i在i'的左边
                i在i'的右边
            区间树：是一种对动态集合进行维护的红黑树，其中每个元素x都包含一个区间x.int。支持插入、删除、查询操作
                基础数据结构
                    每个结点都包含一个区间属性x.int,且x的关键字为区间的低端点x.int.low。数据结构按照中序遍历列出的就是按低端点的次序排列的各区间
                附加信息
                    每个结点还包含一个x.max值，是以x为根的子树所有区间的端点的最大值
                对信息维护
                    x.max = max(x.int.high,x.left.max,x.right.max)
                设计新的操作
    高级设计和分析技术
    十五、动态规划
        通常用于求解最优问题，做出每个选择的同时，通常会生产与原问题形式相同的子问题
        与分治方法相似，都是通过组合子问题的解来求解原问题。不同的是动态规划，应用于子问题重叠的情况，只会求解一次子问题，并将结果保存在数据表中。
        设计步骤
            刻画一个最优解的结构特征
            递归的定义最优解的值
            计算最优解的值，通常采用自底向上的方法
            利用计算出的信息构造一个最优解
        钢条切割
            r(n) = max(p(n),r(1)+r(n-1),...,r(n-1)+r(1))
            最优子结构：在所以切割方案中选取组合收益最大者，构成原问题的最优解。（问题的最优解是由相关子问题组合而成，子问题可以独立求解）
            时空权衡：动态规划是付出额外的内存空间来节省计算时间。
            自顶向下递归实现
                CUT-ROD(p,n)
                    if n==0
                        return 0
                    q = -∞
                    for i=1 to n 
                        q =max(q,p[i]+CUT-ROD(p,n-i))
                    return q;
                function cutRod(p,n){
                    if(n==0){
                        return 0
                    }else{
                        var q = -Infinity;
                        for(var i=0;i<n;i++){
                            q = Math.max(q,p[i]+cutRod(p,n-i))
                        }
                        return q
                    }
                }
            等价方法：
                带备忘的字顶向下法
                    按照自然递归形式编写过程，但过程会保存每个子问题的解，当需要一个子问题的题解时，过程首先检查是否已经保存过此解
                    MEMOIZED-CUT-ROD(p,n)
                        let r[0...n] be a new array 
                        for i=0 to n
                            r[i] = -∞
                        return MEMOIZED-CUT-ROD-AUX(p,n,r)
                    MEMOIZED-CUT-ROD-AUX(p,n,r)
                        if r[n]>=0
                            return r[n]
                        if n==0
                            q =0;
                        else q = -∞
                            for i=0 to n 
                                q =max(q,p[i]+MEMOIZED-CUT-ROD-AUX(p,n-i,r))
                        r[n] = q
                        return q
                自底向上法
                    一般需要恰当定义子问题的规模的概念，使得任何子问题的求解都只依赖于更小的子问题的求解
                    BOTTOM-UP-CUT-ROD(p,n)
                        let r[0...n] be a new array
                        r[0]=0;
                        for j=1 to n
                            q =-∞
                            for i=1 to j 
                                q =max(q,p[i]+r[j-i])
                            r[j] =q;
                        return r[n]
                子问题图
                    自底向上动态规划算法是按“逆拓扑序”或者“反序的拓扑序”来处理子问题图中的定点
                重构解
                    EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
                        let r[0...n]and s[0...n] be a new array 
                        r[0] =0
                        for j=1 to n
                            q =-∞
                            for i=1 to j 
                                if q<p[i]+r[j-i]
                                    q = p[i]+r[j-i]
                                    s[j] =i
                            r[j] = q
                            return r and s
                    PRINT-CUT-ROD-SOLUTION(p,n)
                        (r,s)=EXTENDED-BOTTOM-UP-CUT-ROD(p,n)
                        while n>0
                            print s[n]
                            n = n-s
        矩阵链乘法
            MATRIX-MULTIPLY(A,B)
                IF A.columns!=B.rows
                    error "incompatiable dimensions"
                else let C be a new A.rows*B.columns matrix
                    for i =1 to A.rows
                        for j= 1 to B.columns
                            c(ij) = 0
                            for k=1 to A.columns
                                c(ij) = c(ij)+(a(i,k) * b(kj))
                return C
            相容：两矩阵只有相容，即A的列数等于B的行数，才能相乘。
            矩阵乘法次数  p*q * q*r =>p*q*r
            矩阵链乘法问题：给定n个矩阵的链，矩阵A(i)的规模为p(i-1)*p(i),求完全括号化方案，使得计算乘积A(1)A(2)A(3)...A(n)所需标量乘法次数最少
            计算括号化方案的数量
                            1  n=1
                P(n) = {
                            k=1 to n-1 P(k)*P(n-k)  n>=2
            应用动态规划方法（注意设计步骤）
                最优括号化方案的结构特征
                    动态规划方法第一步就是寻找最优子结构，然后就可以利用这种子结构从子问题的最优解构造出原问题的最优解。
                一个递归求解方案
                    m[i,j] = min({m[i,k]+m[k+1,j]+P(i-1)*P(k)*P(j)})  i<j&&i<=k<j
                计算最优代价
                    MATRIX-CHAIN-ORDER(p)
                        n =p.length-1
                        let m[1...n,1..n] and s[1...n-1,2...n] be a new tables
                        for i=0 to n 
                            m[i,j]=0
                        for l=2 to n
                            for i=i to n-l+1
                                j=i+l-1
                                m[i,j]=∞
                                for k =i to j-1
                                    q = m[i,k]+m[k+1,j]+p(i-1)*p(k)*p(j)
                                    if q<m[i,j]
                                        m[i,j]=q 
                                        s[i,j] = k
                        return m and s
                构造最优解
                    PRINT-OPTIMAL-PARENS(s,i,j)
                        if i==j
                            print "A"
                        else print "("
                            PRINT-OPTIMAL-PARENS(s,i,s[i,j])
                            PRINT-OPTIMAL-PARENS(s,s[i,j]+1,j)
                            print ")"
        动态规划原理
            两要素：最优子结构、问题重叠
            最优子结构
                最优子结构性质：如果一个问题的最优解包含其子问题的最优解。
                遵循通用模式：
                    证明问题最优解的第一个组成部分是做出一个选择。
                    对于一个给定的问题，在其可能的第一步选择中，你假设已经知道哪种选择才会得到最优解。
                    给定获得最优解的选择后，你确定这次选择会产生那些子问题，以及如何最好的刻画子问题空间。
                    利用剪切-粘贴技术证明：作为原问题最优解的组成部分，每个子问题的解就是他们本身的最优解。
            无权最短路径：找到一条u到v的边数最少的路径
            无权最长路径：找到一条u到v的边数最多的简单路径
            重叠子问题
                递归算法反复求解相同子问题
                RECURSIVE-MATRIX-CHAIN(p,i,j)
                    if i == j
                        return 0
                    m[i,j]=0
                    for k=i to j
                        q =RECURSIVE-MATRIX-CHAIN(p,i,k)+RECURSIVE-MATRIX-CHAIN(p,k+1,j)+P(i-1)*P(k)P(j)
                        if q<m[i,j]
                            m[i,j] =q
                    return m[i,j]
            重构最优解
                备忘：
            最长公共子序列（LCS）
                刻画最长公共子序列的特征
                一个递归解
                计算LCS的长度
                构造LCS
                算法改进
            最优二叉搜索树
    十六、贪心算法
        通常用于最优化问题，每一步都追求局部最优，比动态规划速度快
    十七、摊还分析
        直接分析序列整体的实际代价的界。
    高级数据结构
    十八、B树
    十九、斐波那契堆
    二十、Van Emde Boas树
    二十一、用于不想交集合的数据
    图算法
    二十二、基本的图算法
        图的表示
            图的两种标准表示法：（都可以表示无向图和有向图）
                将图作为邻接链表的组合（稀疏图）
                    一个包含|v|条链表的数组Adj所构成，每个结点有一条链条。
                    邻接链表稍加修改，可用来表示权重图，权重图是图中的每条边都带有一个相关的权重图。该权重值通常由一个w:E->R的权重函数给出。
                    邻接链表表示法的鲁棒性很高。
                    无法快速判断一条边(u,v)是否是图的一条边，唯一办法是在邻接链表中搜索Adj[u]里面的结点v
                将图作为邻接矩阵来看待（稠密图）
                    图的邻接矩阵表示由一个V*v的矩阵A=(aij)表示，满足 aij={1(若（i,j）属于E) 0 其他}
                    也可表示权重图
            表示图的属性
                对图进行操作的多数算法需要维持图中结点或边的某些属性。v.d表示结点v的属性d
        广度优先搜索（BFS）
            是最简单的图搜索算法之一，也是许多重要的图算法的原型。
            能够计算从源结点s到每个可到达的结点的距离（最少的边树），同时生成一颗“广度优先搜索树”。
            BFS(G,s)
                for each vertex u∈G.V-{s}
                    u.color =WHITE
                    u.d = ∞
                    u.π =NIL 
                s.color =GRAY
                s.d = 0
                s.π = NIL 
                Q = Φ  (空)
                ENQUEUE(Q,s)
                while Q !=Φ
                    u = DEQUEUE(Q)
                    for each v∈ G.Adj[u]
                        if v.color == WHITE
                            v.color =GRAY
                            v.d = u.d+1
                            v.π = u
                            ENQUEUE(Q,v)
                    u.color = BLACK
            广度优先搜索的结果依赖于对每个结点的邻接结点的访问顺序。
            最短路径
                给定G =(V,E),G为一个有向图或无向图，设s∈V为任意结点，则对于任意边(u,v)∈E,δ(s,v)<=δ(s,u)+1
                设G =(V,E)为一个有向图或无向图，假定BFS以给定结点s∈V作为源结点在图G上运行，那么BFS终结时，对于每个结点v∈V,BFS所计算出的v.d满足v.d>=δ(s,v)
    二十三、最小生成树
    二十四、单源最小路径
    二十五、所有结点对的最短路径
    二十六、最大流
    算法问题的选编
    二十七、多线程算法
    二十八、矩阵运算
    二十九、线性规划


